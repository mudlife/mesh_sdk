C51 COMPILER V9.53.0.0   NETSTACK_APP                                                      07/19/2019 11:47:17 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE NETSTACK_APP
OBJECT MODULE PLACED IN .\Objects\netstack_app.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE app\netstack_app.c LARGE OPTIMIZE(6,SPEED) BROWSE INCDIR(.\app;.\dev;.\o
                    -s;.\inc) DEFINE(LOG,LIGHT) DEBUG OBJECTEXTEND PRINT(.\Listings\netstack_app.lst) TABS(2) OBJECT(.\Objects\netstack_app.o
                    -bj)

line level    source

   1          /**
   2           * @file netstack_app.c
   3           * @brief 应用层文件
   4           * @details 实现具体应用，例如灯功能 LED初始化，开关，亮度调节，色温调节
   5           * @author mudlife
   6           * @par Copyright (c):
   7           *      上海晶曦微电子科技有限公司
   8           * @version 1.0.0
   9           * @date 2019-06-02
  10           */
  11          #include <string.h>
  12          #include "network_conf.h"
  13          #include "netstack_app.h"
  14          //#include "pwm.h"
  15          #include "os.h"
  16          
  17          /**
  18           * @name PWM 引脚定义
  19           * @{
  20           */
  21          #define C_VALUE_L     PWM0DL
  22          #define C_VALUE_H     PWM0DH
  23          #define W_VALUE_L     PWM0DTL
  24          #define W_VALUE_H     PWM0DTH
  25          /** @} */
  26          
  27          /// ADC 引脚定义
  28          #define PIN_AC        P0_0//根据引脚定义
  29          
  30          u8 r_ac_dbs_in;
  31          u8 r_ac_dbs_free;
  32          u8 r_acpower_ready;
  33          
  34          /// 可运行标志位
  35          u8 r_runflag;   
  36          /// 等待次数
  37          u8 r_waittimes;
  38          /**
  39           * @name PWM 需要的值和当前值
  40           * @{
  41           */
  42          u16 r_c_needvalue;
  43          u16 r_w_needvalue;
  44          u16 r_c_nowvalue;
  45          u16 r_w_nowvalue;
  46          /** @} */
  47          
  48          /// ?
  49          u16 r_autosave;
  50          /// 当前次数
  51          u8 r_nowcount;
  52          
  53          u8 r_runningflag;
C51 COMPILER V9.53.0.0   NETSTACK_APP                                                      07/19/2019 11:47:17 PAGE 2   

  54          /// 亮度比 %
  55          char  r_bright;
  56          /// 色温比 %
  57          char r_tone;
  58          ///上电次数
  59          u8 r_poweroncnt;
  60          /// 应用层系统时间
  61          u8 r_systemtime;
  62          /// ?
  63          u8 r_acin;
  64          
  65          extern void net_clear_network();
  66          extern void delay_ms(u16 t);
  67          void led_flash(void);
  68          void F_FlashFuntion(u8 x);
  69          
  70          u8 flash_count;
  71          
  72          ///快捷键 对应的灯光模式
  73          code u8 led_key_model_val[][2] = {
  74                                              {0,100},
  75                                              {50,100},
  76                                              {100,100},
  77                                              {0,50},
  78                                              {50,50},
  79                                              {50,25}};
  80          /// led状态结构定义
  81          Led_Sta_T * led_sta_t;
  82          
  83          
  84          void F_FlashFuntion(u8 x);
  85                                              
  86          /**
  87           * @brief 设置PWM
  88           * 
  89           * @return 无
  90           */                                                                       
  91          static void app_set_def_pwm()
  92          {
  93   1        if(r_w_needvalue != r_w_nowvalue || r_c_needvalue != r_c_nowvalue){
  94   2          C_VALUE_H = (u8)((r_c_nowvalue>>8)&0X03);   
  95   2          C_VALUE_L = (u8)(r_c_nowvalue&0X00FF);
  96   2          W_VALUE_H = (u8)((r_w_nowvalue>>8)&0X03); 
  97   2          W_VALUE_L = (u8)(r_w_nowvalue&0X00FF);
  98   2        }
  99   1      }
 100          
 101          /**
 102           * @brief 清网检测
 103           * 
 104           * @return 无
 105           */ 
 106          void F_CheckClearNet()
 107          {
 108   1        r_poweroncnt = local_info.pweron;
 109   1        r_autosave = 8000;  
 110   1        if((r_poweroncnt==0xa0) || (r_poweroncnt>9))
 111   1        {
 112   2          r_bright = led_sta_t->led_bright;//获取灯的亮度
 113   2          r_tone = led_sta_t->led_tone;   //获取色温值
 114   2          led_sta_t->led_sta = 1;         //灯的状态设置为开灯  
 115   2          
C51 COMPILER V9.53.0.0   NETSTACK_APP                                                      07/19/2019 11:47:17 PAGE 3   

 116   2          if(r_bright>100)
 117   2          {
 118   3            r_bright = 50;
 119   3          }
 120   2          if(r_tone>100)
 121   2          {
 122   3            r_tone = 50;
 123   3          }       
 124   2          r_poweroncnt = 0;
 125   2        }else{
 126   2          r_poweroncnt++; 
 127   2          
 128   2          if((r_poweroncnt%4==0)&&r_poweroncnt!=8)
 129   2          {
 130   3                r_tone = 100;
 131   3                r_bright = 100;   
 132   3                      
 133   3          }
 134   2          else if((r_poweroncnt%4==1))
 135   2          {
 136   3                r_tone = 0;
 137   3                r_bright = 100;     
 138   3          }
 139   2          else if((r_poweroncnt%4==2))
 140   2          {
 141   3                r_tone = 50;
 142   3                r_bright = 100;       
 143   3          }
 144   2          else if((r_poweroncnt%4==3))
 145   2          {
 146   3                r_tone = 50;
 147   3                r_bright = 20;        
 148   3          } 
 149   2          else if(r_poweroncnt==8)
 150   2          {
 151   3                r_tone = 100;
 152   3                r_bright = 100;
 153   3                F_SetBrightToneValue(); 
 154   3                r_c_nowvalue = r_c_needvalue;
 155   3                r_w_nowvalue = r_w_needvalue;
 156   3                app_set_def_pwm();
 157   3          
 158   3                F_FlashFuntion(5);
 159   3                net_clear_network();  
 160   3          }   
 161   2        }
 162   1      
 163   1          local_info.pweron = r_poweroncnt;   
 164   1          net_updat_local_info();
 165   1          F_SetBrightToneValue(); 
 166   1          r_c_nowvalue = r_c_needvalue;
 167   1          r_w_nowvalue = r_w_needvalue;
 168   1          app_set_def_pwm();
 169   1      
 170   1          led_sta_t->led_sta = 1;         //灯的状态设置为开灯   
 171   1      //  F_SetBrightToneValue();   
 172   1      }
 173          
 174          
 175          /**
 176           * @brief 开关灯切换
 177           * 
C51 COMPILER V9.53.0.0   NETSTACK_APP                                                      07/19/2019 11:47:17 PAGE 4   

 178           * @return 无
 179           */ 
 180          void F_SwitchOnOff()
 181          {
 182   1        if(r_acpower_ready)
 183   1        {
 184   2          if(r_acin==0)
 185   2          {
 186   3            r_acin = 1;     
 187   3            PWM0EN = 0x0F;  
 188   3            F_CheckClearNet();
 189   3            r_runflag = 0;      
 190   3          }
 191   2        }
 192   1        else
 193   1        {
 194   2          r_acin = 0;
 195   2          r_runflag = 1;
 196   2          PWM0EN = 0x00;  
 197   2        }
 198   1      }
 199          
 200          
 201          
 202          /**
 203           * @brief 自动保存
 204           * 
 205           * @return 无
 206           */ 
 207          void F_Autosave()
 208          {
 209   1        if((r_systemtime&0x01)==1)
 210   1        {
 211   2          r_systemtime = r_systemtime & 0xfe;
 212   2          if(r_autosave)
 213   2          {
 214   3            r_autosave--;
 215   3            if(r_autosave==0)
 216   3            {
 217   4              led_sta_t->led_bright  =  r_bright;
 218   4              led_sta_t->led_tone = r_tone; 
 219   4              
 220   4      //  r_bright = led_sta_t->led_bright;//获取灯的亮度
 221   4      //  r_tone = led_sta_t->led_tone;   //获取色温值       
 222   4              
 223   4              r_poweroncnt = 0xa0;  
 224   4              local_info.pweron = r_poweroncnt;   
 225   4              net_updat_local_info();       
 226   4            }
 227   3          }
 228   2        }
 229   1        
 230   1      }
 231          
 232          /**
 233           * @brief 闪灯
 234           * 
 235           * @param x 闪灯次数
 236           * @return 无
 237           */ 
 238          void F_FlashFuntion(u8 x)
 239          {
C51 COMPILER V9.53.0.0   NETSTACK_APP                                                      07/19/2019 11:47:17 PAGE 5   

 240   1          r_runflag = 1;
 241   1          while(x)
 242   1          {
 243   2            PWM0EN = 0x00;  
 244   2            WDTC |= 0x10;    //清狗
 245   2            delay_ms(250);
 246   2            PWM0EN = 0x0F;
 247   2            WDTC |= 0x10;    //清狗     
 248   2            delay_ms(250);  
 249   2            x--;
 250   2          }
 251   1          r_runflag = 0;
 252   1      }
 253          
 254          
 255          
 256          
 257          /**
 258           * @brief 应用层进程
 259           * 
 260           * @return 无
 261           * @note while循环调用该函数
 262           */ 
 263          void app_process(void)
 264          {
 265   1      //  F_SwitchOnOff();
 266   1      //  F_Autosave();  //关闭
 267   1      }
 268          
 269          
 270          //void app_Bright()
 271          //{
 272          //  F_BrightUp();
 273          //  os_task_add(30,app_Bright);
 274          //}
 275          
 276           
 277          /**
 278           * @brief 闪灯
 279           * 
 280           * @return 无
 281           */
 282           
 283          void led_flash(void)
 284          {
 285   1        if(led_sta_t->led_sta == 1){
 286   2          led_sta_t->led_sta = 0;
 287   2          PWM0EN = 0x08;
 288   2        }else{
 289   2          led_sta_t->led_sta = 1;
 290   2          PWM0EN = 0x0F;  
 291   2        }
 292   1        if(flash_count>0){
 293   2          flash_count--;
 294   2          os_task_add(500,led_flash);
 295   2        }
 296   1      }
 297          
 298          /**
 299           * @brief APP层初始化
 300           * 
 301           * @return 无
C51 COMPILER V9.53.0.0   NETSTACK_APP                                                      07/19/2019 11:47:17 PAGE 6   

 302           */
 303          u8 app_init(void)
 304          {
 305   1        //1.初始化LED灯
 306   1        
 307   1        P0M0 = P0M0 & 0XF0;
 308   1        
 309   1        r_c_nowvalue = 00;
 310   1        r_w_nowvalue = 00;
 311   1        r_c_needvalue = 00;
 312   1        r_w_needvalue = 00; 
 313   1        r_acin = 0;
 314   1        PWM_Init();
 315   1        
 316   1        //获取设备状态广播参数的缓存区
 317   1        led_sta_t = (Led_Sta_T *)net_get_adv_param_buf();
 318   1        //设置LED的模式   默认为冷暖模式
 319   1        led_sta_t->led_model = CURRENT_LED_MODEL<<LED_MODEL_SHIFT;
 320   1        //设置设备广播参数的长度  长度小于11     当前模式为冷暖模式 ，设备广播参数
             -为4个字节 led_model,led_sta,led_bright,led_tone
 321   1        net_set_adv_param_len(5);
 322   1      //  r_bright = led_sta_t->led_bright;//获取灯的亮度
 323   1      //  r_tone = led_sta_t->led_tone;   //获取色温值
 324   1        led_sta_t->led_sta = 1;         //灯的状态设置为开灯  
 325   1        
 326   1      
 327   1      
 328   1      //  F_CheckClearNet();
 329   1      
 330   1      r_tone = led_key_model_val[1][0];
 331   1      r_bright = led_key_model_val[1][1];
 332   1        F_OpenLed();
 333   1      //os_task_add(30,app_Bright);
 334   1        r_runflag = 0;
 335   1      //  F_Countdata(r_bright,r_tone);
 336   1        
 337   1        return 0;
 338   1      }
 339          
 340          /**
 341           * @brief APP层处理来自网络层的数据包
 342           *
 343           * @param net_pdu 数据包
 344           * @return 返回值用来判断网络层是否发送设备网络广播
 345           *  @retval 0 不发送设备广播
 346           *  @retval 1 放设备广播
 347           * @note 由网络层调用，其他地方不能调用
 348           */
 349          u8 app_input(NET_PDU *net_pdu)
 350          {
 351   1        u8 keytemp = 0; 
 352   1        u8 res = 0;
 353   1        switch(net_pdu->dat.net_cmd.opcode){
 354   2          case CTL_LED_FLASH://闪灯   当设备入网，移除网络，配对，取消配对时会进行闪灯  
             - ，移除网络对码的闪灯需要在2S内完成
 355   2            //net_pdu->dat.net_cmd.param[0]; 1---入网   2---移除网络   3---对码   4---取消对码
 356   2          flash_count = 5;
 357   2          if(led_sta_t->led_sta == 0)
 358   2          {
 359   3            led_sta_t->led_sta = 1;
 360   3            F_OpenLed();
 361   3          }
C51 COMPILER V9.53.0.0   NETSTACK_APP                                                      07/19/2019 11:47:17 PAGE 7   

 362   2      //    
 363   2      //    F_FlashFuntion(3);    
 364   2          
 365   2          os_task_add(1,led_flash);
 366   2          break;
 367   2          case CTL_LED_ON://开灯
 368   2            led_sta_t->led_sta = 1;
 369   2            led_sta_t->ttl = net_pdu->ttl;
 370   2            F_OpenLed();
 371   2          res = 1;
 372   2          break;
 373   2          case CTL_LED_OFF://关灯
 374   2            led_sta_t->led_sta = 0;
 375   2            led_sta_t->ttl = net_pdu->ttl;
 376   2            F_CloseLed();
 377   2          res = 1;
 378   2      
 379   2          break;
 380   2          case CTL_BRIGHT_VAL://设置亮度
 381   2            r_bright = net_pdu->dat.net_cmd.param[1];
 382   2            led_sta_t->led_bright = r_bright;
 383   2            F_SetBrightToneValue();
 384   2            
 385   2        
 386   2          break;
 387   2          case CTL_BRIGHT_UP://亮度+
 388   2            F_BrightUp();
 389   2          break;
 390   2          case CTL_BRIGHT_DOWN://亮度-
 391   2            F_BrightDown();
 392   2          break;
 393   2          case CTL_TONE_VAL://设置色温
 394   2            r_tone = net_pdu->dat.net_cmd.param[0];
 395   2            led_sta_t->led_tone = r_tone;
 396   2            F_SetBrightToneValue();
 397   2          break;
 398   2          case CTL_TONE_UP://色温+
 399   2            F_ToneUp();
 400   2          break;
 401   2          case CTL_TONE_DOWN://色温-
 402   2            F_ToneDown();
 403   2          break;
 404   2          case CTL_KEY_BOARD://快捷键
 405   2          led_sta_t->led_model &= 0xF0;
 406   2          led_sta_t->led_model |= net_pdu->dat.net_cmd.param[0];      
 407   2          keytemp = net_pdu->dat.net_cmd.param[0];
 408   2            r_waittimes = 0;  
 409   2            r_waittimes = 0;  
 410   2            if(keytemp<6){
 411   3              r_tone = led_key_model_val[keytemp][0];
 412   3              r_bright = led_key_model_val[keytemp][1];
 413   3            } 
 414   2          F_SetBrightToneValue(); 
 415   2          app_set_def_pwm();
 416   2      
 417   2          led_sta_t->led_sta = 1;
 418   2          break;
 419   2          case CTL_LED_RGB://RGB
 420   2            
 421   2          break;
 422   2          
 423   2        }
C51 COMPILER V9.53.0.0   NETSTACK_APP                                                      07/19/2019 11:47:17 PAGE 8   

 424   1        
 425   1        led_sta_t->led_bright = r_bright;
 426   1        led_sta_t->led_tone = r_tone;   
 427   1      //  r_poweroncnt = 0xa0;
 428   1      //  local_info.pweron = r_poweroncnt;       
 429   1      //  net_updat_local_info();   
 430   1        r_runningflag = 1;
 431   1        return res;
 432   1      } 
 433          
 434          
 435          /**
 436           * @brief APP层发送数据
 437           *
 438           * @param net_pdu 数据包
 439           * @return APP输出结果
 440           */
 441          
 442          u8 app_output(NET_PDU *net_pdu)
 443          {
 444   1      
 445   1        return 0;
 446   1      }
*** WARNING C280 IN LINE 442 OF app\netstack_app.c: 'net_pdu': unreferenced local variable
 447          
 448          
 449          
 450          /**
 451           * @brief 开灯
 452           * 
 453           * @return 无
 454           */
 455          void F_OpenLed()
 456          {
 457   1        r_waittimes = 1;  
 458   1        F_Countdata(r_bright,r_tone);
 459   1      
 460   1      }
 461          /**
 462           * @brief 关灯
 463           * 
 464           * @return 无
 465           */
 466          void F_CloseLed()
 467          {
 468   1        r_waittimes = 1;
 469   1        r_c_needvalue = 0;
 470   1        r_w_needvalue = 0;
 471   1      }
 472          
 473          
 474          /**
 475           * @brief 亮度加
 476           * 
 477           * @return 无
 478           */
 479          void F_BrightUp()
 480          {
 481   1            if(r_c_needvalue>=r_c_nowvalue || r_w_needvalue>=r_w_nowvalue)
 482   1            {
 483   2              if((r_c_needvalue - r_c_nowvalue)<50 || (r_w_needvalue - r_w_nowvalue)<50)
 484   2              {
C51 COMPILER V9.53.0.0   NETSTACK_APP                                                      07/19/2019 11:47:17 PAGE 9   

 485   3                r_bright = r_bright + 5;
 486   3                if(r_bright>100)
 487   3                {
 488   4                  r_bright = 100;
 489   4                }   
 490   3      
 491   3                r_waittimes = 2;      
 492   3                F_Countdata(r_bright,r_tone);         
 493   3              }
 494   2            }
 495   1            
 496   1      }
 497          
 498          /**
 499           * @brief 亮度减
 500           * 
 501           * @return 无
 502           */
 503          void F_BrightDown()
 504          {
 505   1          if(r_c_needvalue<=r_c_nowvalue || r_w_needvalue<=r_w_nowvalue)
 506   1            {
 507   2              if((r_c_nowvalue - r_c_needvalue)<50 || (r_w_nowvalue - r_w_needvalue)<50)
 508   2              {
 509   3                r_bright = r_bright - 5;
 510   3                if(r_bright<5)
 511   3                {
 512   4                  r_bright = 5;
 513   4                }   
 514   3                r_waittimes = 2;      
 515   3                F_Countdata(r_bright,r_tone);         
 516   3              }
 517   2            }
 518   1                
 519   1      }
 520          
 521          
 522          
 523          
 524          /**
 525           * @brief 色温加
 526           * 
 527           * @return 无
 528           */
 529          void F_ToneUp()
 530          {
 531   1      
 532   1          if(r_c_needvalue>=r_c_nowvalue || r_w_needvalue>=r_w_nowvalue)
 533   1          {
 534   2              
 535   2              if((r_c_needvalue - r_c_nowvalue)<50 || (r_w_needvalue - r_w_nowvalue)<50)
 536   2              {
 537   3                r_waittimes = 2;
 538   3                r_tone = r_tone + 5;
 539   3                if(r_tone>100)
 540   3                {
 541   4                  r_tone = 100;
 542   4                }   
 543   3                r_waittimes = 2;  
 544   3                F_Countdata(r_bright,r_tone);   
 545   3              }
 546   2          }
C51 COMPILER V9.53.0.0   NETSTACK_APP                                                      07/19/2019 11:47:17 PAGE 10  

 547   1      
 548   1      }
 549          /**
 550           * @brief 色温减
 551           * 
 552           * @return 无
 553           */
 554          void F_ToneDown()
 555          {
 556   1        if(r_c_needvalue<=r_c_nowvalue || r_w_needvalue<=r_w_nowvalue)
 557   1          {
 558   2              
 559   2              if((r_c_nowvalue - r_c_needvalue)<50 || (r_w_nowvalue - r_w_needvalue)<50)
 560   2              {
 561   3                r_tone = r_tone - 5;
 562   3                if(r_tone<10)
 563   3                {
 564   4                  r_tone = 0;
 565   4                }   
 566   3                r_waittimes = 2;  
 567   3                F_Countdata(r_bright,r_tone);   
 568   3              }
 569   2          }
 570   1      }
 571          
 572          /**
 573           * @brief 设置亮度和色温值
 574           * 
 575           * @return 无
 576           */
 577          void F_SetBrightToneValue()
 578          {
 579   1        r_waittimes = 0;    
 580   1        F_Countdata(r_bright,r_tone); 
 581   1      }
 582          
 583          
 584          /**
 585           * @brief ADC 检测
 586           * 
 587           * @return 无
 588           */
 589          void F_AcPowerDect()
 590          {
 591   1        if(PIN_AC)
 592   1        {
 593   2          r_ac_dbs_in++;
 594   2          r_ac_dbs_free = 0;
 595   2          if(r_ac_dbs_in>2)
 596   2          {
 597   3            r_acpower_ready = 1;
 598   3          }   
 599   2        }
 600   1        else
 601   1        {
 602   2          r_ac_dbs_free++;
 603   2          r_ac_dbs_in = 0;
 604   2          if(r_ac_dbs_free>30)
 605   2          {
 606   3            r_acpower_ready = 0;
 607   3          }           
 608   2        }
C51 COMPILER V9.53.0.0   NETSTACK_APP                                                      07/19/2019 11:47:17 PAGE 11  

 609   1      }
 610          
 611          
 612          
 613          
 614          
 615          
 616          
 617          /**
 618           * @brief 应用层中断处理函数
 619           * 
 620           * @return 无
 621           * @note 用来跟新PWM
 622           */
 623          void F_CWRunning(void)
 624          {
 625   1          r_systemtime = 0xff;
 626   1      //    F_AcPowerDect();
 627   1          if(r_runflag==0) //;r_runningflag
 628   1          {
 629   2            if(r_nowcount>=r_waittimes)
 630   2            {
 631   3              r_nowcount=0;
 632   3          
 633   3              if(r_c_needvalue>r_c_nowvalue)
 634   3              {
 635   4                r_c_nowvalue++;
 636   4              }
 637   3              else if(r_c_needvalue<r_c_nowvalue)
 638   3              {
 639   4                r_c_nowvalue--;         
 640   4              }
 641   3              if(r_w_needvalue>r_w_nowvalue)
 642   3              {
 643   4                r_w_nowvalue++;
 644   4              }
 645   3              else if(r_w_needvalue<r_w_nowvalue)
 646   3              {
 647   4                r_w_nowvalue--;         
 648   4              }       
 649   3              
 650   3              app_set_def_pwm();
 651   3      
 652   3      
 653   3              if((r_c_needvalue==r_c_nowvalue)&&(r_w_needvalue==r_w_nowvalue))
 654   3              {
 655   4                  r_runningflag = 0;          
 656   4              }       
 657   3            }
 658   2            else
 659   2            {
 660   3              r_nowcount++;
 661   3            }
 662   2          }
 663   1          
 664   1      }
 665          
 666          
 667          
 668          /**
 669           * @brief 根据亮度和色温比计算PWM
 670           * 
C51 COMPILER V9.53.0.0   NETSTACK_APP                                                      07/19/2019 11:47:17 PAGE 12  

 671           * @param x_Bright 亮度百分比
 672           * @param y_Tone 色温百分比
 673           * @return 无
 674           * @note 要避免浮点型运算，比价耗费资源
 675           */
 676          void F_Countdata(const u8 x_Bright,const u8 y_Tone)
 677          {
 678   1        u32 temp1,temp2;
 679   1        u16 temp3,temp4;
 680   1        if((x_Bright<101)&&(y_Tone<101)){
 681   2          //1.计算色温
 682   2          //计算公式  PWM1 + PWM2 = 100%
 683   2          temp1 = y_Tone*10;
 684   2          temp2 = 1000 - temp1;
 685   2          
 686   2          //2.计算亮度
 687   2          //计算公式 PWM * 亮度%
 688   2      
 689   2          temp3 = ( x_Bright*temp1/100);
 690   2          temp4 = (x_Bright*temp2/100);
 691   2          
 692   2          r_c_needvalue = temp4;  //暖光
 693   2          r_w_needvalue = temp3;  //冷光
 694   2        }
 695   1        
 696   1      }
 697          
 698          
 699          
 700          
 701          
 702          /**
 703           * @brief PWM初始化
 704           *
 705           * @return 无
 706           */
 707          void PWM_Init(void)
 708          {
 709   1        P2M1 = (P2M1&0x0F)|0xC0; //P23  
 710   1        P0M0 = (P0M1&0x00)|0xCC; //P00 , P01
 711   1        PWM01_MAP = 0x23;         //PWM01通道映射P23口
 712   1        PWM0_MAP = 0x01;          //PWM0通道映射P01口
 713   1        
 714   1      //  P2M2 = (P2M2&0xF0)|0x08;
 715   1      //  P2M3 = (P2M3&0xF0)|0x08;
 716   1      //  PWM01_MAP = 0x26;         //PWM01通道映射P23口
 717   1      //  PWM0_MAP = 0x24;          //PWM0通道映射P01口    
 718   1            
 719   1        
 720   1        PWM0C       = 0X00;           //  128分频
 721   1        PWM0EN      = 0x0F;     
 722   1        
 723   1        PWM0PH = 0X03;            
 724   1        PWM0PL = 0XE8;        
 725   1        
 726   1        PWM0DH = 0x00;            
 727   1        PWM0DL = 0x00;      
 728   1        PWM0DTH = 0x00;           
 729   1        PWM0DTL = 0x00;     
 730   1       
 731   1      
 732   1      }
C51 COMPILER V9.53.0.0   NETSTACK_APP                                                      07/19/2019 11:47:17 PAGE 13  

 733          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2443    ----
   CONSTANT SIZE    =     12    ----
   XDATA SIZE       =     26      20
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
